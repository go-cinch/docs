# Goä»£ç è§„èŒƒ

å‚è€ƒä¸€äº›å¤§å‚å¼€æºè§„èŒƒ, ç­›é€‰ä¸€éƒ¨åˆ†ä½œä¸ºGoè§„èŒƒ  
<b>åŸåˆ™: ä»£ç å†™ç»™äººçœ‹çš„, ä¸æ˜¯å†™ç»™æœºå™¨çœ‹, æœ‰æ—¶ç”šè‡³å¯ä»¥ç‰ºç‰²ä¸€éƒ¨åˆ†æ€§èƒ½</b>

## åŸºæœ¬è§„èŒƒ(å†…ç½®äºlint)

å·²ç»å†…ç½®åˆ°lintè§„èŒƒæ–‡ä»¶`.golangci.yml`, åˆ°é¡¹ç›®æ ¹ç›®å½•æ‰§è¡Œä¸‹åˆ—å‘½ä»¤å³å¯éªŒè¯æ˜¯å¦ç¬¦åˆåŸºæœ¬è§„èŒƒ

```makefile
make lint
```

!> Tip: å®Œæ•´è§„èŒƒå‚è€ƒ[revive](https://revive.run/r), å¯æ ¹æ®æŠ¥é”™æ ‡é¢˜æ¥æŸ¥æ‰¾é”™è¯¯åŸå› ,
æµ‹è¯•ç”¨ä¾‹[revive/testdata](https://github.com/mgechev/revive/tree/master/testdata)

### å•è¡Œå­—ç¬¦é•¿åº¦

ä¸è¶…è¿‡`150`, è¶…å‡ºå­—ç¬¦, åˆç†æ¢è¡Œ, ä¸‹åˆ—åœºæ™¯ä¾‹å¤–

- importè¯­å¥
- è‡ªåŠ¨ç”Ÿæˆçš„ä»£ç å—
- ç»“æ„ä½“tag
- *_test.goä¸­çš„ä»£ç 

### å‡½æ•°å‚æ•°ä¸ªæ•°

ä¸è¶…è¿‡`5`, è¶…å‡ºæ—¶å¯ä½¿ç”¨[å‡½æ•°å¯é€‰å‚æ•°](/standard/1.go?id=%e5%87%bd%e6%95%b0%e5%8f%af%e9%80%89%e5%8f%82%e6%95%b0)

### å‡½æ•°å“åº”ä¸ªæ•°

ä¸è¶…è¿‡`5`, è¶…å‡ºæ—¶å¯å°è£…æˆç»“æ„ä½“è¿”å›

### ç©ºå¼•ç”¨

importæœªä½¿ç”¨çš„åŒ…(Ideaä¸€èˆ¬è‡ªåŠ¨å»é™¤)

### é‡å¤å¼•ç”¨

importé‡å¤çš„åŒ…(Ideaä¸€èˆ¬è‡ªåŠ¨å»é™¤)

### boolå¸¸é‡

ä¸éœ€è¦åˆ¤æ–­boolå¸¸é‡å€¼
bad:

```
// å®šä¹‰boolå¸¸é‡
const ( 
  Ok = true
  Fail = false
)
func MyFun() {
  ...
  
  // åˆ¤æ–­Okæ˜¯å¦ç­‰äºtrue
  if Ok == true {
    fmt.Println("ok")
  }
  
  // åˆ¤æ–­Failæ˜¯å¦å¦ç­‰äºtrue
  if Fail == false {
    fmt.Println("fail")
  }
  ...
}
```

### åˆ¤æ–­ç»“æœæ˜¯å¸¸é‡

bad:

```
// num<numæ°¸è¿œä¸ºfalseä¸éœ€è¦åˆ¤æ–­
func MyFun(num float64) bool {
  return num < num
}
```

### context.Contextå‚æ•°

context.Contextä¸Šä¸‹æ–‡æ˜¯golangä¸­é‡è¦çš„å‚æ•°, æœ‰è¿™ä¸ªå‚æ•°æ—¶, æ”¾åœ¨ç¬¬ä¸€ä½
bad:

```
func MyFun(num float64, ctx context.Context) {
  ...
}
```

good:

```go
func MyFun(ctx context.Context, num float64) {
  ...
}
```

### errorå“åº”

æœ‰errorè¿”å›å€¼æ—¶, æ”¾åœ¨æœ€åä¸€ä½
bad:

```
func MyFun() (error, int) {
  return nil, 0
}
```

good:

```go
func MyFun() (int, error) {
  return 0, nil
}
```

### ç»“æŸç¨‹åº

ä¸è¦åœ¨init/mainä»¥å¤–çš„å…¶ä»–å‡½æ•°ä½¿ç”¨ç»“æŸç¨‹åºç›¸å…³å‘½ä»¤
bad:

```
func init() {
  ...
}
func main() {
  ...
  MyFun()
  ...
}
func MyFun() {
  os.Exit(1)
  // log.Fatalf(1)
  // syscall.Exit(1)
}
```

?> Tip: init/mainä¼šåœ¨å¯åŠ¨ç¨‹åºæ˜¯æ‰§è¡Œ, é…ç½®ä¸æ»¡è¶³è¦æ±‚æˆ–å…¶ä»–åŸå› å¯ä¸»åŠ¨ç»“æŸç¨‹åº, è€Œå…¶ä»–å‡½æ•°ä¸åº”è¯¥ä¸»åŠ¨ç»“æŸç¨‹åº

### defer

#### ä¸è¦åœ¨å¾ªç¯å†…ä½¿ç”¨defer

bad:

```
  for {
    defer func() {
      ...
    }
  }
```

#### ä¸è¦ç›´æ¥ä½¿ç”¨recover

bad:

```
  recover()
```

bad:

```
  defer recover()
```

good:

```go
  defer func() {
    e := recover()
    if e != nil {
      ...
    }
    ...
  }()
```

### å‡å°‘else

bad:

```
func MyFun(ctx context.Context) {
  if ctx != nil {
    ...
  } else {
    return
  }
  return
}
```

good:

```go
func MyFun(ctx context.Context) {
  if ctx == nil {
    return
  }
  return
}
```

### ç›´æ¥return err

bad:

```
func Check() error {
  ...
}
func MyFun() error {
  ...
  if err = Check(); err != nil {
    return err
  }
  // è¿™é‡Œå¹¶æ²¡æœ‰å…¶ä»–å¤„ç†é€»è¾‘
  return nil
}
```

good:

```go
func Check() error {
  ...
}
func MyFun() error {
  ...
  return Check()
}
```

### ç©ºä»£ç å—

bad:

```
// ifå†…æ²¡æœ‰ä»»ä½•ä»£ç é€»è¾‘, åº”è¯¥ç§»é™¤
if xxx {
}
```

### Get/getæ–¹æ³•

è‡³å°‘æœ‰ä¸€ä¸ªè¿”å›å€¼
bad:

```
func GetMyFun() { 
  ...
}
```

good:

```
func GetMyFun() string { 
  ...
  return "ok"
}
```

### è‡ªå¢1

ä½¿ç”¨`i++`æˆ–`i--`æ›¿æ¢`i+=1`æˆ–`i-=1`
bad:

```
func MyFun() { 
  var i int
  i += 1
  ...
}
```

good:

```go
func MyFun() { 
  var i int
  i++
  ...
}
```

### ä¿®æ”¹å€¼

bad:

```
type Foo struct {
  num   int
  key   *string
  items map[string]bool
}
func (u Foo) Change() {
  // ä½ æƒ³ä¿®æ”¹num, è¢«å¤–éƒ¨æ¥æ”¶, ä½†intä¸æ˜¯å¼•ç”¨ç±»å‹, ä¸”å½“å‰æ–¹æ³•æ²¡æœ‰æŒ‡é’ˆ
  u.num = 8
  *u.key = "v.key"
  u.items["ok"] = true
}
```

good:

```go
type Foo struct {
  num   int
  key   *string
  items map[string]bool
}
// è¿™é‡ŒåŠ ä¸€ä¸ªæŒ‡é’ˆ
func (u *Foo) Change() {
  u.num = 8
  *u.key = "v.key"
  u.items["ok"] = true
}
```

?> Tip: å½“ç„¶ä½ ä¹Ÿå¯ä»¥æŠŠnumæ”¹æˆ`*int`

### range

#### 1. rangeç¬¬äºŒä¸ªå€¼

ä¸ä½¿ç”¨æ—¶ä¸å†™
bad:

```
func MyFun(m map[string]interface{}) {
  for k, _ := range m {
    ...
  }
}
```

good:

```go
func MyFun(m map[string]interface{}) {
  for k := range m {
    ...
  }
}
```

#### 2. routineä¸­ä½¿ç”¨rangeçš„å€¼

é€šè¿‡å‚æ•°ä¼ å…¥go routine, å¦åˆ™å¯èƒ½å¯¼è‡´å€¼ä¸å¯¹
bad:

```
func MyFun(m map[string]interface{}) {
  for k, v := range m {
    go func() {
	  fmt.Println(k, v)
	}()
  }
}
```

good:

```go
func MyFun(m map[string]interface{}) {
  for k, v := range m {
    go func(key string, val interface{}) {
	  fmt.Println(k, v)
	}(key, val)
  }
}
```

### æ–¹æ³•æ¥æ”¶è€…

è‡ªå®šä¹‰ç±»å‹ä¸­, æ¯ä¸ªæ–¹æ³•æ¥æ”¶è€…å˜é‡åç§°ä¿æŒä¸€è‡´
bad:

```
type foo struct{}
func (this foo) f1() {
}
func (self foo) f2() {
}
```

good:

```go
type foo struct{}
func (self foo) f1() {
}
func (self foo) f2() {
}
```

### æ•´æ•°è½¬å­—ç¬¦ä¸²

é€šè¿‡`strconv.Itoa()`å°†æ•´æ•°è½¬ä¸ºå­—ç¬¦ä¸²
bad:

```
a := string(1)
```

good:

```go
a := strconv.Itoa(1)
```

### ç»“æ„ä½“æ ‡ç­¾

æ ‡ç­¾éœ€ç¬¦åˆä¸€å®šè§„èŒƒ

### æˆå‘˜å˜é‡å‘½å

æˆå‘˜å˜é‡ä½¿ç”¨å°é©¼å³°
bad:

```
func MyFun() {
  A := "123"
  fmt.Println(A)
  return
}
```

good:

```go
func MyFun() {
  num := "123"
  fmt.Println(num)
  return
}
```

### returnç§æœ‰æˆå‘˜

å¯¹å¤–æš´éœ²çš„å‡½æ•°, è¿”å›å€¼å¿…é¡»æ—¶å…¬å…±æˆå‘˜
bad:

```
type foo struct{}
func MyFun() foo {
  return foo{}
}
```

good:

```go
type Foo struct{}
func MyFun() Foo {
  return Foo{}
}
```

### æ°¸è¿œä¸ä¼šæ‰§è¡Œ

bad:

```
func MyFun() string {
  return "ok"
  fmt.Println("ok")
}
```

good:

```go
func MyFun() string {
  fmt.Println("ok")
  return "ok"
}
```

### æœªä½¿ç”¨çš„å‚æ•°

bad:

```
func MyFun(str string) string {
  return "ok"
}
```

good:

```go
func MyFun(_ string) string {
  return "ok"
}
```

or:

```go
func MyFun() string {
  return "ok"
}
```

### æœªä½¿ç”¨çš„æ¥æ”¶è€…

bad:

```
type foo struct{}
func (self foo) myFun() {
  fmt.Println("ok")
}
```

good:

```go
type foo struct{}
func (foo) myFun() {
  fmt.Println("ok")
}
```

### WaitGroupå‚æ•°

WaitGroupç”¨ä½œå‚æ•°, å¿…é¡»æŒ‡é’ˆä¼ é€’, å¦åˆ™è°ƒç”¨æ–¹æ³•å¯èƒ½ä¸ä¼šç”Ÿæ•ˆ
bad:

```
func MyFun(wg sync.WaitGroup) {
  ...
}
```

good:

```go
func MyFun(wg *sync.WaitGroup) {
  ...
}
```

!> ä¸€èˆ¬æå°‘æ•°æƒ…å†µ, WaitGroupä¼šç”¨ä½œå‚æ•°

## å‘½åè§„èŒƒ

!> <font color=red>æ‰€æœ‰å‘½åå¿…é¡»ä¸ºæœ‰å®é™…æ„ä¹‰çš„è‹±æ–‡å‘½åï¼Œå°½é‡ä¸è¦éšæ„ä½¿ç”¨å•å­—æ¯ï¼Œå¦‚aï¼Œbï¼Œcï¼Œxï¼Œyï¼Œzï¼Œq1ï¼Œq2ç­‰</font>

?> ps. é¦–å­—æ¯å¤§å†™çš„é©¼å³°å¼ï¼Œä»¥ä¸‹ç®€ç§°ä¸º`å¤§é©¼å³°`ï¼›é¦–å­—æ¯å°å†™çš„é©¼å³°å¼ï¼Œä»¥ä¸‹ç®€ç§°ä¸º`å°é©¼å³°`

### æ¥å£å

ä½¿ç”¨`å¤§é©¼å³°`

* æ·»åŠ æ“ä½œï¼Œä½¿ç”¨`Create`ä½œä¸ºå‰ç¼€ï¼Œå¦‚`CreateUser`
* åˆ é™¤æ“ä½œï¼Œä½¿ç”¨`Delete`ä½œä¸ºå‰ç¼€ï¼Œå¦‚`DeleteUser`
* ä¿®æ”¹æ“ä½œï¼Œä½¿ç”¨`Update`ä½œä¸ºå‰ç¼€ï¼Œå¦‚`UpdateUser`
* æŸ¥è¯¢æ“ä½œï¼Œå•æ¡æ•°æ®ä½¿ç”¨`Get`ä½œä¸ºå‰ç¼€ï¼Œå¦‚`GetUser`ï¼Œå¤šæ¡æ•°æ®ä½¿ç”¨`Find`ä½œä¸ºå‰ç¼€ï¼Œæ— éœ€å¤æ•°åŒ–ï¼Œå¦‚`FindUser`ï¼Œè€Œä¸æ˜¯`FindUsers`

### æ–¹æ³•å

* publicæ–¹æ³•ï¼Œä½¿ç”¨`å¤§é©¼å³°`ï¼Œå¦‚`GetUser`
* privateæ–¹æ³•ï¼Œä½¿ç”¨`å°é©¼å³°`ï¼Œå¦‚`getUser`
  é™¤æ­¤ä¹‹å¤–ï¼Œè¿˜å¯ä»¥åŠ ä¸Šä¸€äº›åç¼€æ¥å¢å¼ºæè¿°ï¼Œå¦‚`GetUserById`ï¼Œ`FindUserByName`

### ç»“æ„ä½“å‘½å

* modelï¼Œä½¿ç”¨`å¤§é©¼å³°`ï¼Œå¦‚`User`
* requestï¼Œä½¿ç”¨`å¤§é©¼å³°`ï¼ŒåŠ æ“ä½œå‰ç¼€ï¼ŒåŠ `Request`åç¼€ï¼Œå¦‚`GetUserRequest`
* replyï¼Œä½¿ç”¨`å¤§é©¼å³°`ï¼ŒåŠ æ“ä½œå‰ç¼€ï¼ŒåŠ `Reply`åç¼€ï¼Œå¦‚`GetUserReply`

### å˜é‡å

ä½¿ç”¨`å°é©¼å³°`ï¼Œå¦‚`userName`

### å¸¸é‡å

**å…¨å¤§å†™**åŠ ä¸‹åˆ’çº¿åˆ†å‰²å•è¯ï¼Œå¦‚`USER_NAME`

### æ–‡ä»¶å

* `go`æ–‡ä»¶åå…¨éƒ¨å°å†™, é€šè¿‡ä¸‹åˆ’çº¿(`_`)éš”å¼€å¤šä¸ªå•è¯, å¦‚`user_info.go`
* `yml`/`sql`/`proto`æ–‡ä»¶åå…¨éƒ¨å°å†™, é€šè¿‡æ¨ªæ (`-`)éš”å¼€å¤šä¸ªå•è¯,
  å¦‚`my-config.yml`, `2022081510-game.sql`, `user-info.proto`

## å¼ºåˆ¶è§„èŒƒ

### æ…ç”¨æˆ–ä¸ç”¨panic

ä¸è¦éšæ„ä½¿ç”¨panic, å“ªæ€•å®šä¹‰defer, è¿™æ ·æ˜¯å±é™©çš„æ“ä½œ

### é›¶å€¼

#### 1. [slice](https://github.com/golang/go/wiki/CodeReviewComments#declaring-empty-slices)

bad:

```
    t := []string{}
```

good:

```go
    var t []string
```

jsonæ•°æ®ä½¿ç”¨(é¿å…è¢«è§£æä¸ºnull):

```go
    t := make([]string, 0)
```

#### 2. [é”](https://github.com/uber-go/guide/blob/master/style.md#zero-value-mutexes-are-valid)

##### å•æ¬¡ä½¿ç”¨

æ— éœ€ä½¿ç”¨å¸¦æŒ‡é’ˆçš„é”

bad:

```
    mu := new(sync.Mutex)
    mu.Lock()
```

good:

```go
    var mu sync.Mutex
    mu.Lock()
```

#### map

bad:

```
    m := map[string]interface{}{}
```

good:

```go
    m := make(map[string]interface{})
```

##### åµŒå…¥ç»“æ„ä½“

å³ä¾¿é”æ˜¯ç§æœ‰æˆå‘˜ä¹Ÿä¸è¦æŠŠé”ç›´æ¥åµŒå…¥åˆ°ç»“æ„ä½“ä¸­, éœ€å®šä¹‰ä¸€ä¸ªå­—æ®µå

bad:

```
    type SMap struct {
      sync.Mutex
    
      data map[string]string
    }
```

good:

```go
    type SMap struct {
      mu sync.Mutex
    
      data map[string]string
    }
```

### [å‡å°‘else](https://github.com/golang/go/wiki/CodeReviewComments#indent-error-flow)

å¯ä»¥é¿å…ä½¿ç”¨elseçš„åœºæ™¯å°½é‡ä½¿ä»£ç å˜å¾—ç®€æ´

#### 1. erråˆ¤æ–­

bad:

```
    if err != nil {
        // error handling
    } else {
        // normal code
    }
```

good:

```go
    if err != nil {
        // error handling
        return // or continue, etc.
    }
    // normal code
```

#### 2. è¿”å›å€¼erråˆ¤æ–­

bad:

```
    if x, err := f(); err != nil {
        // error handling
        return
    } else {
        // use x
    }
```

good:

```go
    x, err := f()
    if err != nil {
        // error handling
        return
    }
    // use x
```

#### 3. è¿”å›å€¼boolç±»å‹åˆ¤æ–­

bad:

```
    if v, ok := a.(string); !ok {
        // not ok handling
        return
    } else {
        // use v
    }
```

good:

```go
    v, ok := a.(string)
    if !ok {
        // not ok handling
        return
    }
    // use v
```

### æ¥å£

#### [æ¥å£åˆç†æ€§æ£€æŸ¥](https://github.com/uber-go/guide/blob/master/style.md#verify-interface-compliance)

bad:

```
    // å¦‚æœ Handler æ²¡æœ‰å®ç° http.Handlerï¼Œä¼šåœ¨è¿è¡Œæ—¶æŠ¥é”™
    type Handler struct {
      // ...
    }
    
    func (h *Handler) ServeHTTP() {
      ...
    }
```

good:

```go
    type Handler struct {
      // ...
    }
    
    // å¦‚æœ Handler æ²¡æœ‰å®ç° http.Handlerï¼Œä¼šåœ¨ç¼–è¯‘æœŸæŠ¥é”™
    var _ http.Handler = (*Handler)(nil)
    
    func (h *Handler) ServeHTTP() {
      // ...
    }
```

### [åˆ‡ç‰‡æˆ–mapæ‹·è´](https://github.com/uber-go/guide/blob/master/style.md#zero-value-mutexes-are-valid)

#### 1. ä¿®æ”¹å€¼å‰å…ˆcopyä¸€ä»½

bad:

```
    func (d *Driver) SetTrips(trips []Trip) {
      d.trips = trips
    }
    
    trips := ...
    d1.SetTrips(trips)
    
    trips[0] = ...
    // çŒœä¸‹ä¿®æ”¹åd1.trips[0]å€¼ä¼šå˜å—?
```

good:

```go
    func (d *Driver) SetTrips(trips []Trip) {
      d.trips = make([]Trip, len(trips))
      copy(d.trips, trips)
    }
    
    trips := ...
    d1.SetTrips(trips)
    
    trips[0] = ...
    // è¿™é‡Œä¿®æ”¹äº†trips[0], d1.tripsä¸ä¼šå‘ç”Ÿæ”¹å˜
```

#### 2. returnå‰å…ˆcopyä¸€ä»½

bad:

```
    type Stats struct {
      mu sync.Mutex
      counters map[string]int
    }
    
    func (s *Stats) Snapshot() map[string]int {
      s.mu.Lock()
      defer s.mu.Unlock()
    
      return s.counters
    }
    
    snapshot := stats.Snapshot()
    // çŒœä¸‹é«˜å¹¶å‘åœºæ™¯ä¸‹snapshotä¼šå‘ç”Ÿæ•°æ®ç«äº‰å—?
```

good:

```go
    type Stats struct {
      mu sync.Mutex
      counters map[string]int
    }
    
    func (s *Stats) Snapshot() map[string]int {
      s.mu.Lock()
      defer s.mu.Unlock()
    
      result := make(map[string]int, len(s.counters))
      for k, v := range s.counters {
        result[k] = v
      }
      return result
    }
    
    snapshot := stats.Snapshot()
    // é«˜å¹¶å‘åœºæ™¯ä¸‹snapshotä¸ä¼šå‘ç”Ÿæ•°æ®ç«äº‰
```

### defer

#### deferä¸­å®Œæˆèµ„æºå›æ”¶

bad:

```
    p.Lock()
    if p.count < 10 {
      p.Unlock()
      return p.count
    }
    
    p.count++
    newCount := p.count
    p.Unlock()
    
    return newCount
    // å¦‚æœä¸€ä¸ªæ–¹æ³•æœ‰10ä¸ªreturn, ä½ æ•¢ç¡®ä¿ä¸ä¸¢å¤±Unlockå—?
```

good:

```go
    p.Lock()
    defer p.Unlock()
    
    if p.count < 10 {
      return p.count
    }
    
    p.count++
    return p.count
    
    // more readable
```

?> Tip: åŒç†å¯ä»¥å»¶ä¼¸åˆ°channel/connectionç­‰èµ„æºåœ¨deferä¸­å…³é—­

### å­—ç¬¦ä¸²æ‹¼æ¥

å­—ç¬¦ä¸²æ‹¼æ¥ç»“æœå¯èƒ½å¾ˆé•¿æ—¶, å¼ºåˆ¶ä½¿ç”¨strings.Join(), ç‰¹æ®Šåœºæ™¯å¯ä»¥ä½¿ç”¨strings.Builder

bad:

```
    // ä½¿ç”¨.å°†a/b/cæ‹¼æ¥èµ·æ¥
    a := "..."
    b := "..."
    c := "..."
    
    fmt.Sprintf("%s.%s.%s", a, b, c)
    // OR
    a + "." + b + "." + c
```

good:

```go
    strings.Join([]strings{a, b, c}, ".")
```

!> éœ€è¦è·å–errorå †æ ˆå¯ä»¥ä½¿ç”¨fmt.Sprintf("%+v", err)

### å•è¡Œå­—ç¬¦é•¿åº¦

ä¸è¶…è¿‡100, è¶…å‡ºå­—ç¬¦, åˆç†æ¢è¡Œ, ä¸‹åˆ—åœºæ™¯ä¾‹å¤–

- importè¯­å¥
- è‡ªåŠ¨ç”Ÿæˆçš„ä»£ç å—
- ç»“æ„ä½“tag
- *_test.goä¸­çš„ä»£ç 

### æ³¨é‡Š//+ç©ºæ ¼+æ–‡å­—

bad:

```
//è¿™æ®µä»£ç ä½œç”¨æ˜¯
```

good:

```go
// è¿™æ®µä»£ç ä½œç”¨æ˜¯
```

### å£°æ˜

#### 1. importä½¿ç”¨å®Œæ•´è·¯å¾„

bad:

```
import "../user"
```

good:

```go
import "xxx.com/project/user"
```

##### 2. ç›¸ä¼¼æ•°æ®æ”¾åœ¨ä¸€èµ·

bad:

```
import "a"
import "b"
```

good:

```go
import (
  "a"
  "b"
)
```

è¿™åŒæ ·é€‚ç”¨äºå¸¸é‡ã€å˜é‡å’Œç±»å‹å£°æ˜

bad:

```
const a = 1
const b = 2
var a = 1
var b = 2
type Area float64
type Volume float64
```

good:

```go
const (
  a = 1
  b = 2
)
var (
  a = 1
  b = 2
)
type (
  Area float64
  Volume float64
)
```

ä¸ç›¸å…³çš„ä¸æ”¾åœ¨ä¸€èµ·:

bad:

```
type Operation int
const (
  Add Operation = iota + 1
  Subtract
  Multiply
  EnvVar = "MY_ENV"
)
```

good:

```go
type Operation int
const (
  Add Operation = iota + 1
  Subtract
  Multiply
)
const EnvVar = "MY_ENV"
```

## æ¨èä½¿ç”¨

### ä½¿ç”¨iotaå®šä¹‰å¸¸é‡

bad:

```
const (
  Zero  int = 0
  One   int = 1
  Two   int = 2
  Three int = 3
)
```

good:

```go
const (
  Zero int = iota
  One
  Two
  Three
)
```

?> Tip: iotaå¯¹äº`int8`/`int16`/`int32`/`int64`/`uint`/`uint8`/`uint16`/`uint32`/`uint64`éƒ½é€‚ç”¨å“¦

### [å‡½æ•°å¯é€‰å‚æ•°](https://github.com/uber-go/guide/blob/master/style.md#functional-options)

å½“å‡½æ•°æœ‰å¤šä¸ªå‚æ•°æ—¶, ä½¿ç”¨Functional Optionsè®©è°ƒç”¨å˜å¾—ç®€æ´

bad:

```
// package db
func Open(
  addr string,
  cache bool,
  logger *zap.Logger
) (*Connection, error) {
  // ...
}
// call Open
db.Open(addr, db.DefaultCache, zap.NewNop())
db.Open(addr, db.DefaultCache, log)
db.Open(addr, false /* cache */, zap.NewNop())
db.Open(addr, false /* cache */, log)
```

good:

```go
// package db
type Option interface {
  // ...
}
func WithCache(c bool) Option {
  // ...
}
func WithLogger(log *zap.Logger) Option {
  // ...
}
// Open creates a connection.
func Open(
  addr string,
  opts ...Option,
) (*Connection, error) {
  // ...
}
// call Open
db.Open(addr)
db.Open(addr, db.WithLogger(log))
db.Open(addr, db.WithCache(false))
db.Open(
  addr,
  db.WithCache(false),
  db.WithLogger(log),
)
```

### æ—¥å¿—ä¸Šä¸‹æ–‡

æ—¥å¿—ä¸€èˆ¬ç»‘å®šä¸Šä¸‹æ–‡è¾“å‡º, æ–¹ä¾¿è¿½è¸ª(æ¯ä¸ªè¯·æ±‚ä¸€èˆ¬éƒ½ä¼šæœ‰context)

bad:

```
log.Info("ok")
```

good:

```go
log.
  WithContext(ctx).
  Info("ok")
```

### ç²¾åº¦ä¸¢å¤±

#### 1. é«˜ç²¾åº¦æµ®ç‚¹æ•°

ä½¿ç”¨[decimal](https://github.com/shopspring/decimal)ç±»å‹æ¥å®šä¹‰æµ®ç‚¹æ•°, è€Œä¸æ˜¯float64, å¸¸ç”¨äºç²¾åº¦è¦æ±‚é«˜çš„åœºæ™¯, å¦‚è®¢å•é‡‘é¢

#### 2. jsonè¿”å›å€¼

æ•°å­—ç±»å‹è½¬ä¸ºjson, å€¼è¾ƒå¤§æ—¶å¯èƒ½ä¼šæº¢å‡º, å®šä¹‰ç»“æ„ä½“tagæ—¶è½¬ä¸ºstring

bad:

```
type User struct {
  Id int64 `json:"id"`
}
// ä¸€ä¸ªè¾ƒå¤§çš„id
user := User{
    Id: 9223372036854775807,
}
u, _ := json.Marshal(user)
fmt.Println(string(u))
// golangè¾“å‡ºæ˜¯å¯¹çš„
// {"id":9223372036854775807}
// ç»™å‰ç«¯jsè§£æä¸€ä¸‹
// JSON.parse(`{"id":9223372036854775807}`)
// {id: 9223372036854776000}
```

good:

```go
type User struct {
  Id int64 `json:"id,string"`
}
// ä¸€ä¸ªè¾ƒå¤§çš„id
user := User{
    Id: 9223372036854775807,
}
u, _ := json.Marshal(user)
fmt.Println(string(u))
// {"id":"9223372036854775807"}
// ç»™å‰ç«¯jsè§£æä¸€ä¸‹, å­—ç¬¦ä¸²é¿å…è½¬æ¢å¸¦æ¥çš„æº¢å‡º
// JSON.parse(`{"id":"9223372036854775807"}`)
// {id: '9223372036854775807'}
```

?> Tip: å¯¹äº`uint64`ä¹Ÿé€‚ç”¨å“¦

### å¤šä½¿ç”¨æ³›å‹

golangç‰ˆæœ¬å·²å‡çº§åˆ°1.20, å¤šä½¿ç”¨æ³›å‹å¯æå‡å¼€å‘æ•ˆç‡ä»¥åŠæ€§èƒ½

### å¸¸é‡æ‰©å±•

å®šä¹‰å¸¸é‡æ—¶, æœ‰æ—¶å€™å¯èƒ½éœ€è¦æ‰©å±•å…¶å«ä¹‰, ç”¨äºæ‰“å°æ—¥å¿—æˆ–å‰ç«¯å±•ç¤º

bad:

```
const (
	Dict1 uint8 = iota
	Dict2
	Dict3
	Dict4
)
var Dict = map[uint8]string{
	Dict1: "dict1",
	Dict2: "dict2",
	Dict3: "dict3",
	Dict4: "dict4",
}
type Param struct {
    MyDict Dict `json:"myDict"`
}
// 1. åˆ¤æ–­å‚æ•°æ˜¯å¦åˆæ³•
var p Param
// bind param
...
// ä½¿ç”¨mapåˆ¤æ–­keyæ˜¯å¦å­˜åœ¨
if v, ok := Dict[p.MyDict]; !ok {
    // invalid
    return
}
// valid
// æ‰“å°æ—¥å¿—, è¾“å‡ºå¸¸é‡å¯¹åº”å­—ç¬¦ä¸²
log.Info(Dict[p.MyDict])
```

good:

```go
// è‡ªå®šä¹‰uint8ç±»å‹
type DictCategory uint8
const (
	Dict1 DictCategory = iota
	Dict2
	Dict3
	Dict4
)
func (d DictCategory) String() string {
	switch d {
	case Dict1:
		return "dict1"
	case Dict2:
		return "dict2"
	case Dict3:
		return "dict3"
	case Dict4:
		return "dict4"
	}
	// è¿™é‡Œå¯ä»¥ä½¿ç”¨unknown, ä¹Ÿå¯ä»¥ä½¿ç”¨ç©ºå­—ç¬¦ä¸²
	return "unknown"
}
type Param struct {
    MyDict Dict `json:"myDict"`
}
// 1. åˆ¤æ–­å‚æ•°æ˜¯å¦åˆæ³•
var p Param
// bind param
...
// ç›´æ¥ä½¿ç”¨stringæ–¹æ³•
if p.MyDict == "unknown" {
    // invalid
    return
}
// valid
// æ‰“å°æ—¥å¿—, è¾“å‡ºå¸¸é‡å¯¹åº”å­—ç¬¦ä¸²
log.Info(p.MyDict.String())
```

## æ•°æ®åº“è§„èŒƒ

é¡¹ç›®æ·±åº¦é›†æˆGorm, åœ¨`data`ç›®å½•è°ƒç”¨æ•°æ®åº“ç›¸å…³æ–¹æ³•æ³¨æ„äº‹é¡¹å¦‚ä¸‹

### äº‹åŠ¡

ç³»ç»Ÿé€šè¿‡ä¸Šä¸‹æ–‡å†…ç½®äº‹åŠ¡, å…·ä½“ç”¨æ³•çœ‹[è¿™é‡Œ](/base/2.db?id=äº‹åŠ¡)

### è¿”å›å€¼Idå’ŒID

gorm/genç”Ÿæˆçš„æ•°æ®åº“`id`å­—æ®µå¯¹åº”åˆ°goç»“æ„ä½“æ˜¯`ID`  
protoæ–‡ä»¶ç”Ÿæˆ`id`å­—æ®µå¯¹åº”åˆ°goç»“æ„ä½“æ˜¯`Id`(å½“ç„¶ä¹Ÿå¯ä»¥æŠŠprotoæ–‡ä»¶idæ”¹æˆi_d, ä½†è¿™æ ·çœ‹èµ·æ¥å°±å¤ªå¥‡æ€ªäº†)
å› æ­¤`data`æ•°æ®è¿”å›ç»™`biz`å‰ç”¨`copierx`è½¬æ¢å¤„ç†

```go
rp := make([]biz.Game, 0)
list := make([]model.Game, 0)
...
copierx.Copy(&rp, list)
```

### Gorm Gen

é¡¹ç›®å†…ç½®gorm/gen, åœ¨`data`ç›®å½•ä¸‹ä¼šç”Ÿæˆä¸¤ä¸ªå­ç›®å½•

- `model` - æ•°æ®åº“æ˜ å°„ç»“æ„ä½“ç›®å½•
- `query` - gorm/genæŸ¥è¯¢æ–¹æ³•æ˜ å°„, åŒ…å«gormé»˜è®¤æŸ¥è¯¢æ–¹æ³•ä»¥åŠè‡ªå®šä¹‰æ‰©å±•æ–¹æ³•
  å…¶ä¸­, ä¸ºäº†æŸ¥è¯¢æ–¹ä¾¿, queryå†…ç½®äº†å‡ ä¸ªå¸¸ç”¨çš„è‡ªå®šä¹‰æ‰©å±•æ–¹æ³•,
  æºç åœ¨[è¿™é‡Œ](https://github.com/go-cinch/common/blob/plugins/gorm/filter/v1.0.0/plugins/gorm/filter/filter.go)
- `GetByID(id uint64) gen.T`
    - ç”¨é€”: è·å–å•æ¡æ•°æ®
    - åœºæ™¯: æ ¹æ®idè·å–æ•°æ®
- `GetByCol(col, val string) gen.T`
    - ç”¨é€”: æ ¹æ®æŒ‡å®šåˆ—è·å–å•æ¡æ•°æ®, å•ä¸ªvalæ”¯æŒå‰åæ·»åŠ `%`è‡ªåŠ¨è½¬ä¸º`LIKE`æ¨¡ç³ŠæŸ¥è¯¢, ç¤ºä¾‹: col=name, val=%å¼ ä¸‰%, ä¸‹åŒ
    - åœºæ™¯: æ ¹æ®å”¯ä¸€ç´¢å¼•è·å–æ•°æ®
- `GetByCols(cols, vals []string) gen.T`
    - ç”¨é€”: æ ¹æ®æŒ‡å®šå¤šåˆ—è·å–å•æ¡æ•°æ®
    - åœºæ™¯: æ ¹æ®å¤šåˆ—è·å–ä¸€æ¡å”¯ä¸€æ•°æ®
- `FindByCol(col, val string) []gen.T`
    - ç”¨é€”: æ ¹æ®æŒ‡å®šåˆ—è·å–å¤šæ¡æ•°æ®
    - åœºæ™¯: æ ¹æ®åˆ—è·å–æ•°æ®, éå”¯ä¸€ç´¢å¼•, å¯èƒ½å¾—åˆ°å¤šæ¡æ•°æ®
- `FindByCols(cols, vals []string) []gen.T`
    - ç”¨é€”: æ ¹æ®æŒ‡å®šå¤šåˆ—è·å–å¤šæ¡æ•°æ®
    - åœºæ™¯: æ ¹æ®å¤šåˆ—è·å–æ•°æ®, éå”¯ä¸€ç´¢å¼•, å¯èƒ½å¾—åˆ°å¤šæ¡æ•°æ®
      !> `FindByCol`æˆ–`FindByCols`æŸ¥è¯¢æ•°æ®å¾ˆå¤šæ—¶ç¦æ­¢ä½¿ç”¨, æ²¡æœ‰åˆ†é¡µ, å¯èƒ½ä¼šå¯¼è‡´å†…å­˜è¿‡å¤§, å“åº”è¶…æ—¶

### DB

è·å–DBå®ä¾‹ä½¿ç”¨å†…ç½®æ–¹æ³•
gorm/genå®ä¾‹

```go
p := query.Use(ro.data.DB(ctx)).Game
db := p.WithContext(ctx)
```

- `p`è¡¨ç¤ºparamså‚æ•°çš„æ„æ€, ç®€å†™ä¸ºpæ˜¯ä¸ºäº†ä¸‹é¢ä½¿ç”¨æ–¹ä¾¿
- `Game`æ˜¯æ•°æ®åº“å®ä½“åç§°, è¡¨ç¤ºæŸ¥è¯¢`game`è¡¨, å¦‚æœè¦æŸ¥è¯¢`order`è¡¨, ç”¨`Order`
- `WithContext`æ˜¯ä¸ºäº†è¿½è¸ªæ—¥å¿—
  è·å–gormåŸç”Ÿå®ä¾‹

```go
p := query.Use(ro.data.DB(ctx)).Game
db := p.WithContext(ctx).UnderlyingDB()
```

?> Tip: ä¸€äº›å¸¸è§çš„éœ€æ±‚, ä½¿ç”¨gorm/genå°±å¤Ÿäº†, æœ‰äº›å¤æ‚çš„åœºæ™¯å¯èƒ½ä¼šç”¨gormåŸç”Ÿ

### éšè—SQLæ—¥å¿—

æŸäº›æƒ…å†µä¸‹, ä¸æƒ³SQLè¯­å¥æ‰“å°åˆ°æ—¥å¿—, å¦‚æ›´æ–°å¯†ç ç­‰æ•æ„Ÿæ“ä½œ, å¯ä»¥è¿™æ ·ç”¨

```go
ctx = ro.data.HiddenSQL(ctx)
p := query.Use(ro.data.DB(ctx)).Game
db := p.WithContext(ctx)
```

åŒä¸€ä¸ªctxä¸‹, æ‰€æœ‰SQLè¾“å‡ºéƒ½æ˜¯`(sql is hidden)`, ç±»ä¼¼

```bash
INFO ts=2023-05-22T16:27:43+08:00 service.id=192.168.5.105 service.name=layout service.version= trace.id= span.id= caller= msg=[18.129ms] [rows:1] (sql is hidden)
```

### `(é£˜å·)

Whereæ¡ä»¶keyå¢åŠ `åŒ…è£¹

bad:

```
db.Where("id = ?", id)
```

gormåŸç”Ÿåšæ³•

good:

```go
db.Where("`id` = ?", id)
```

gorm/genåšæ³•, å†…ç½®å¥½äº†æ— éœ€å…³å¿ƒ

?> æœ‰äº›å­—æ®µæ˜¯mysqlå…³é”®å­—æˆ–é¢„ç•™å­—æ®µ, å¦‚æœæ²¡æœ‰é£˜å·åŒ…è£¹å¯èƒ½å¯¼è‡´æŸ¥è¯¢å¼‚å¸¸, å¦‚`type`/`key`

### ?

ä¸€èˆ¬ä½¿ç”¨`?`é˜²æ­¢SQLæ³¨å…¥, ä»»ä½•æƒ…å†µä¸‹çš„æ‹¼æ¥å­—ç¬¦ä¸²éƒ½ä¸èƒ½é˜²æ­¢æ³¨å…¥

bad:

```
db.Where("`name` = " + name)
```

gormåŸç”Ÿåšæ³•

good:

```go
db.Where("`name` = ?", name)
```

gorm/genåšæ³•, å†…ç½®å¥½äº†æ— éœ€å…³å¿ƒ

### æ—¶é—´èŒƒå›´æŸ¥è¯¢

- ä»`00:00:00`å¼€å§‹åˆ°`00:00:00`ç»“æŸ
- å¼€å§‹ç”¨`>=`, ç»“æŸç”¨`<`

bad:

```
SELECT ... FROM ... WHERE start_time >= '2023-05-23 00:00:00' AND start_time <= '2023-05-23 23:59:59'
```

good:

```mysql
SELECT ... FROM ... WHERE start_time >= '2023-05-23 00:00:00' AND start_time < '2023-05-23 00:00:00'
```

?> Tip: `23:59:59`æç«¯æƒ…å†µä¸‹ä¼šä¸¢å¤±`23:59:59` - `00:00:00`ä¹‹é—´ä¸€ç§’æ•°æ®

### *First

æŸ¥è¯¢å•æ¡æ•°æ®æ—¶ä¸€èˆ¬ä¼šç”¨åˆ°`Fisrt`æ–¹æ³•

`Idæ˜¯å¦å¤§äº0`æˆ–`Idæ˜¯å¦ç­‰äº0(åªé™äºidæ˜¯æ­£æ•´æ•°)`å¯åˆ¤æ–­æ˜¯å¦æˆåŠŸè·å–æ•°æ®(è¡¨ä¸­æ²¡æœ‰Idå­—æ®µæ—¶é€šè¿‡å…¶ä»–å­—æ®µæŒ‰éœ€åˆ¤æ–­)

bad:

```
var m model.Game
p := query.Use(ro.data.DB(ctx)).Game
db := p.WithContext(ctx).UnderlyingDB()
err := db.
  Where("`id` = ?", id).
  First(&m).
  Error
if err == gorm.ErrRecordNotFound {
  // not found
  return
} else if err != nil {
  // other err
  return
}
// found
```

gormåŸç”Ÿåšæ³•

good:

```go
p := query.Use(ro.data.DB(ctx)).Game
db := p.WithContext(ctx).UnderlyingDB()
db.
  Where("`id` = ?", id).
  First(&m)
if m.Id == constant.UI0 {
  // not found
  return
}
// found
```

gorm/genåšæ³•

good:

```go
p := query.Use(ro.data.DB(ctx)).Game
db := p.WithContext(ctx)
m := db.GetByID(id)
if m.ID == constant.UI0 {
  // not found
  return
}
// found
```

?> Tip: ä½¿ç”¨`First(&m).Error`ä¼šå¤šåˆ¤æ–­ä¸€å±‚err

### *Find

æŸ¥è¯¢å¤šæ¡æ•°æ®æ—¶, æŸ¥è¯¢å‚æ•°æºå¸¦[`page.Page`](https://github.com/go-cinch/common/tree/page/v1.0.3/page), æ›´ä¾¿æ·å¤„ç†åˆ†é¡µ

ä»¥`Game.Find`ä¸ºä¾‹

bad:

```
func (ro gameRepo) Find(ctx context.Context, condition *biz.FindGame) (rp []biz.Game) {
  db := ro.data.DB(ctx)
  db = db.
    Model(&Game{}).
    Order("id DESC")
  rp = make([]biz.Game, 0)
  list := make([]Game, 0)
  if condition.Name != nil {
    db.Where("`name` LIKE ?", strings.Join([]string{"%", *condition.Name, "%"}, ""))
  }
  if condition.Age != nil {
    db.Where("`age` = ?", condition.Age)
  }
  db.
    Limit(0).
    Offset(10).
    Find(&list)
  copierx.Copy(&rp, list)
  return
}
```

gormåŸç”Ÿåšæ³•

good:

```go
func (ro gameRepo) Find(ctx context.Context, condition *biz.FindGame) (rp []biz.Game) {
  p := query.Use(ro.data.DB(ctx)).Game
  db := p.WithContext(ctx).UnderlyingDB()
  db = db.
    Model(&Game{}).
    Order("id DESC")
  rp = make([]biz.Game, 0)
  list := make([]Game, 0)
  if condition.Name != nil {
    db.Where("`name` LIKE ?", strings.Join([]string{"%", *condition.Name, "%"}, ""))
  }
  if condition.Age != nil {
    db.Where("`age` = ?", condition.Age)
  }
  // Primaryä½œç”¨æ˜¯ä¼˜åŒ–è¶…å¤§limitæŸ¥è¯¢
  condition.Page.Primary = "id"
  condition.Page.
    WithContext(ctx).
    Query(db).
    Find(&list)
  copierx.Copy(&rp, list)
  return
}
```

gorm/genåšæ³•

good:

```go
func (ro gameRepo) Find(ctx context.Context, condition *biz.FindGame) (rp []biz.Game) {
  p := query.Use(ro.data.DB(ctx)).Game
  db := p.WithContext(ctx)
  rp = make([]biz.Game, 0)
  list := make([]model.Game, 0)
  conditions := make([]gen.Condition, 0, 2)
  if condition.Name != nil {
    conditions = append(conditions, p.Name.Like(strings.Join([]string{"%", *condition.Name, "%"}, "")))
  }
  if condition.Age != nil {
    conditions = append(conditions, p.Age.Eq(*condition.Age))
  }
  condition.Page.Primary = "id"
  condition.Page.
    WithContext(ctx).
    Query(
      db.
        Order(p.ID.Desc()).
        Where(conditions...).
        UnderlyingDB(),
    ).
    Find(&list)
  copierx.Copy(&rp, list)
  return
}
```

?> Tip: çœ‹èµ·æ¥`db.Limit(0).Offset(10)`æ›´ç®€å•, ä½†`page.Page`å¢åŠ limitåˆæ³•æ ¡éªŒ(ä¸åˆæ³•é‡ç½®ä¸ºé»˜è®¤å€¼), ä»¥åŠå¤§åˆ†é¡µæŸ¥è¯¢ä¼˜åŒ–

### *IN

æŸ¥è¯¢æ•°æ®ç¬¦åˆæŸä¸ªåˆ—è¡¨ä¸”åˆ—è¡¨æ•°é‡ä¸å¤šæ—¶, å¯ä»¥ç”¨`IN`

gormåŸç”Ÿåšæ³•

good:

```go
ids := []uint64{1,2,3,5}
db.Where("`id` IN (?)", ids)
```

gorm/genåšæ³•

good:

```go
ids := []uint64{1,2,3,5}
db.Where(p.ID.In(ids))
```

?> å¦‚æœèƒ½å¤Ÿé¢„è§idsæ•°æ®é‡éå¸¸å¤§æ—¶, ä¸åº”è¯¥ç”¨IN, å¦åˆ™ä¼šå¯¼è‡´å…¨è¡¨æ‰«æ, ä¸€èˆ¬ä½¿ç”¨`JOIN`ä¼˜åŒ–, ä½†ä¹Ÿéœ€è¦ç»“åˆå®é™…æƒ…å†µ,
çœ‹MySQLæ‰§è¡Œè®¡åˆ’æ¥ä¼˜åŒ–

### FOR UPDATE

Gormé€šè¿‡`db.Clauses`å®ç°`SELECT ... FROM TABLE FOR UPDATE ...`, ä½†éœ€è¦æ³¨æ„, FOR UPDATEè‡³å°‘ä¿è¯`æœ‰ä¸€ä¸ªæ¡ä»¶`,
å¤šä¸ªæ¡ä»¶æœ€`æœ‰ç´¢å¼•`, æ‰èƒ½é”å®šè¾ƒå°‘çš„è®°å½•, å¦åˆ™å¯èƒ½å¯¼è‡´é”è¡¨, å…¶ä»–è¯·æ±‚ä»»ä½•æ“ä½œéƒ½ä¼šè¢«blockåŒ…æ‹¬read

bad:

```go
// ä¸åŠ ä»»ä½•æ¡ä»¶, å¯¼è‡´userè¡¨è¢«é”å®š
db.
  Clauses(clause.Locking{Strength: "UPDATE"}).
  Find(&users)
```

gormåŸç”Ÿåšæ³•

good:

```go
db.
  Clauses(clause.Locking{Strength: "UPDATE"}).
  // å¢åŠ whereæ¡ä»¶åªä¼šé”å®šuser.id=100å•æ¡è®°å½•
  Where("`id` = ?", 100).
  Find(&users)
```

gorm/genåšæ³•

good:

```go
db.
  Clauses(clause.Locking{Strength: "UPDATE"}).
  // å¢åŠ whereæ¡ä»¶åªä¼šé”å®šuser.id=100å•æ¡è®°å½•
  Where(p.ID.Eq(100)).
  Find(&users)
```

?> FOR UPDATEæ¯”è¾ƒå¸¸ç”¨, å…¶ä»–åœºæ™¯å‚è€ƒGormå®˜æ–¹[Locking](https://gorm.io/docs/advanced_query.html#Locking-FOR-UPDATE)æ–‡æ¡£

## CRUDåŸºæœ¬è§„èŒƒ

ä»¥orderè¡¨ä½œç®€å•æ¼”ç¤º

### å®‰è£…æœ€æ–°cinchå·¥å…·

```bash
go install github.com/go-cinch/cinch/cmd/cinch@latest
```

### åˆ›å»ºSQLæ–‡ä»¶

```bash
# -næ–‡ä»¶åç¼€
# -tæ•°æ®åº“è¡¨å
cinch gen sql -n order -t order
# ğŸº Generate sql migration file success: internal/db/migrations/2023052216-order.sql
```

### æŒ‰éœ€ä¿®æ”¹SQLæ–‡ä»¶

æ·»åŠ å­—æ®µæˆ–ç´¢å¼•

```mysql
-- +migrate Up
CREATE TABLE `order`
(
  `id`         BIGINT UNSIGNED AUTO_INCREMENT COMMENT 'auto increment id' PRIMARY KEY,
  `created_at` DATETIME(3) NULL COMMENT 'create time',
  `updated_at` DATETIME(3) NULL COMMENT 'update time',
  -- enable soft delete, do this:
  -- `deleted_at` DATETIME(3) NULL COMMENT 'delete time',
  `your_field` VARCHAR(50) COMMENT 'your field comment'
) ENGINE = InnoDB
  DEFAULT CHARSET = utf8mb4
  COLLATE = utf8mb4_general_ci;
-- create table index, do this:
-- CREATE UNIQUE INDEX `idx_your_field` ON `order` (`your_field`);
-- +migrate Down
DROP TABLE `order`;
```

### åº”ç”¨åˆ°æ•°æ®åº“

ä¿®æ”¹`configs/gen.yml`ä¸­mysqlçš„`dsn`, å¦‚æˆ‘çš„é…ç½®å¦‚ä¸‹

```yml
gen:
  dsn: "root:root@tcp(127.0.0.1:3306)/layout?charset=utf8mb4&collation=utf8mb4_general_ci&parseTime=True&loc=Local&timeout=10000ms"
```

```bash
cinch gen migrate up
# Applied 1 migration
```

### ç”Ÿæˆgormå®ä½“

#### ç®€å•å®ä½“(æ— ä»»ä½•å…³è”)

```bash
cinch gen gorm
# 2023/05/22 17:03:16 got 3 columns from table <game>
# 2023/05/22 17:03:16 got 4 columns from table <order>
# 2023/05/22 17:03:16 Start generating code.
# 2023/05/22 17:03:16 generate model file(table <order> -> {model.Order}): go-layout/internal/data/model/order.gen.go
# 2023/05/22 17:03:16 generate model file(table <game> -> {model.Game}): go-layout/internal/data/model/game.gen.go
# 2023/05/22 17:03:16 generate query file: go-layout/internal/data/query/order.gen.go
# 2023/05/22 17:03:16 generate query file: go-layout/internal/data/query/game.gen.go
# 2023/05/22 17:03:16 generate query file: go-layout/internal/data/query/gen.go
# 2023/05/22 17:03:16 Generate code done.
```

æˆ–æŒ‡å®šå“ªäº›è¡¨ç”Ÿæˆå®ä½“, å¦‚æœæŒ‡å®šä¸å­˜åœ¨çš„è¡¨ä¼šæŠ¥é”™

```bash
cinch gen gorm -t game,order
```

#### å¤æ‚å®ä½“(ä¸€å¯¹ä¸€ã€å¤šå¯¹å¤šç­‰å…³è”)

```bash
# æ³¨æ„å¤§å°å†™ä¸€ä¸€å¯¹åº”, å¯èƒ½å¯¼è‡´ç”Ÿæˆçš„å­—æ®µæœ‰è¯¯
# userè¡¨éœ€è¦å…³è”roleè¡¨, åœ¨Userç»“æ„ä½“ä¸­çš„å­—æ®µåæ˜¯Role, ä¸€ä¸ªuseræœ‰ä¸€ä¸ªroleæ˜¯has_oneå…³ç³», gorm tagå†…å®¹æ˜¯foreignKey:RoleID
cinch gen gorm -a "user|role|Role|has_one|foreignKey:RoleID"
```

?> Tip: å»ºè®®é…ç½®åœ¨`configs/gen.yml`ä¸‹, ä¸ç„¶å…¶ä»–å¼€å‘è€…å¹¶ä¸çŸ¥é“æ‰§è¡Œå†å², å¦‚æœä»–æŒ‰é»˜è®¤å‘½ä»¤æ‰§è¡Œ, å¯èƒ½å¯¼è‡´å†å²ç”Ÿæˆçš„å®ä½“è¢«è¦†ç›–,
å‚è€ƒ[`auth/configs/gen.yml`](https://github.com/go-cinch/auth/blob/v1.0.3/configs/gen.yml)

### å¼€å§‹CRUD

æŒ‰[æ•°æ®åº“è§„èŒƒ](/standard/1.go?id=æ•°æ®åº“è§„èŒƒ)å¼€å§‹å¼€å‘`data`å±‚CRUD
